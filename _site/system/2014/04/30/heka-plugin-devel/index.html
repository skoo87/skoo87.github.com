
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>skoo  Heka插件开发</title>
    
    <meta name="author" content="skoo">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/twitter/css/pygments.css?body=1" rel="stylesheet" type="text/css" media="all">

    <style>
      code {
        font-size: 13px;
        padding: 1px 1px;
        color: #2980B9;
        background-color: ;
        border: 0px solid white;
        white-space: nowrap;
      }

      pre{
        display:block;
        padding:9.5px;
        margin:0 0 5px;
        font-size:11px;
        line-height:15px;
        word-break:break-all;
        word-wrap:break-word;
        white-space:pre;
        white-space:pre-wrap;
        background-color:;
        border:0px;
        border:0px;
        -webkit-border-radius:0px;
        -moz-border-radius:0px;
        border-radius:0px;
      }
      pre.prettyprint{margin-bottom:10px;}
    </style>

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div style="background-color: #E74C3C">
      <div class="container-fluid">
        <div class="row-fluid" style="color:#ECF0F1">
          <div class="span11">
            <h3><a href="/" style="color:#ECF0F1">skoo's notes</a></h3>
            <small>努力记录一些自己觉得有趣的东西...</small>
          </div>

          <div class="span1">
            <h4><a href="/skoo.html">About</a></h4>
          </div>
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span9">
          <div class="content" style="font-size:15px">
            
<div class="page-header">
  <h3>Heka插件开发</h3>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="date">
      <span>30 April 2014</span>
    </div>
    <div class="author">
      <span>by <a href="/skoo.html">skoo</a></span>
    </div>
    <div class="content">
      <p>Heka是一个实时数据收集、处理和分析的工具，具备高可扩展的插件开发能力。本文是自己调研Heka插件开发的一个总结，方便快速入门插件开发。</p>

<p>2014 gophercon上关于Heka的演讲Slide：<a href='https://cdn.rawgit.com/gophercon/2014-talks/master/rob_miller_heka/index.html#/'>https://cdn.rawgit.com/gophercon/2014-talks/master/rob_miller_heka/index.html#/</a>，从这个Slide中借用一张Heka内部架构图：</p>
<div align='center'>
<img height='300' src='/assets/images/heka-overview-diagram.png' width='600' />
</div>
<p>内部架构图清晰的反应出了数据从进入Heka到流出Heka的整个过程需要经历一些什么样的组件。图中的箭头符号反应出了，一个数据进入Heka后可以选择什么样的路径，路径并不是唯一的，一切都可以根据需求来设置。</p>

<p>内部架构图中展示的所有组件，我们可以通过开发插件定制的部分分别是：Inputs、Decoders、Filters和Outputs。</p>
<br />
<h4 id='id19'>编译源码</h4>

<ol>
<li>
<p>从github上克隆出Heka源码库</p>

<pre><code>git clone https://github.com/mozilla-services/heka</code></pre>
</li>

<li>
<p>查看Heka已经release的版本，其实就是打的tag</p>

<pre><code>git tag</code></pre>

<p>我看到的最新release版本是v0.5.1，因此我们选择这个最新版本的代码：</p>

<pre><code>git checkout v0.5.1</code></pre>
</li>

<li>
<p>现在可以编译当前最新版本v0.5.1代码了(windows平台忽略，暂时只关心Linux平台)</p>

<pre><code>sh build.sh</code></pre>

<p>build.sh脚本是Heka的编译工具，整个工程是通过cmake来管理的。第一次build过程可能比较慢，因为还会下载一些其他的依赖库和工具，不过不需要人为干预，坐等build完成即可。build完成后，当前源码目录下多出一个build目录： <div>
<img height='280' src='/assets/images/heka-build.png' width='450' />
</div></p>

<p>build目录中的heka目录是我们需要关注的。这里放置了所有编译结果，包括heka可执行的二进制文件等。 <div>
<img height='200' src='/assets/images/heka-build-bin.png' width='500' />
</div> <strong>hekad</strong>文件就是我们最关心的二进制执行文件。只需要这个二进制加上配置文件就可以运行整个Heka软件。</p>
</li>
</ol>
<br />
<h4 id='heka'>配置Heka实例</h4>

<p>为了能够直观的感受Heka，我们配置一个简单的实例，让它监控本机上的nginx access日志目录，实时的读取增量日志，并做条数统计，然后将结果打印到屏幕。</p>

<p>Nginx Access日志的目录路径是：</p>

<pre><code>/Users/marckywu/projects/logserver2/tmp/logs</code></pre>

<p>Nginx Access日志文件名(不做rotation)是：</p>

<pre><code>access.log</code></pre>

<p>Nginx Access日志format是：</p>

<pre><code>&#39;$remote_addr - [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;</code></pre>

<p>基于这三个必要的信息，Heka配置文件如下：</p>

<pre><code>[hekad]
base_dir = &quot;/tmp/hekad/cache&quot;
share_dir = &quot;/Users/marckywu/github/heka/build/heka&quot;


[LogstreamerInput]
log_directory = &quot;/Users/marckywu/projects/logserver2/tmp/logs&quot;
file_match = &#39;access\.log&#39;
decoder = &quot;FxaNginxAccessDecoder&quot;


[FxaNginxAccessDecoder]
type = &quot;SandboxDecoder&quot;
script_type = &quot;lua&quot;
filename = &quot;/Users/marckywu/github/heka/sandbox/lua/decoders/nginx_access.lua&quot;
module_directory = &quot;modules&quot;
    [FxaNginxAccessDecoder.config]
    log_format = &#39;$remote_addr - [$time_local] &quot;$request&quot; $status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;
    type = &quot;nginx&quot;


[CounterFilter]
message_matcher = &quot;Type == &#39;nginx&#39;&quot;

[print]
type = &quot;LogOutput&quot;
message_matcher = &quot;Type == &#39;heka.counter-output&#39;&quot;</code></pre>

<p>将配置文件保存为hekad.toml，注意heka的配置文件是toml语法。我们启动hekad进程：</p>

<pre><code>bin/hekad -config hekad.toml</code></pre>

<p>这个时候，Heka已经开始监控nginx access日志了，只要有日志数据，就会读取并处理。我们用ab发送100个请求给nginx，产生100条日志看看Heka的打印效果：</p>

<pre><code>2014/04/30 13:54:36 &lt;
	Timestamp: 2014-04-30 13:54:36.136374705 +0800 CST
	Type: heka.counter-output
	Hostname: WudeMacBook-Pro.local
	Pid: 56972
	UUID: 0ed1f5c9-5691-45f9-9c4d-a044b70f17ad
	Logger:
	Payload: Got 100 messages. 20.00 msg/sec
	EnvVersion:
	Severity: 7
	Fields: []
&gt;</code></pre>

<p>上面打印到屏幕中的<strong>Payload: Got 100 messages. 20.00 msg/sec</strong>，就是counter插件的统计计算结果，counter插件是Heka自带的一个filter插件，这里打印到屏幕也是用的Heka自带的LogOut插件。</p>
<br />
<h4 id='id20'>插件编译</h4>

<p>在我们克隆出来的Heka源码目录中有一个examples目录，里面有几个插件开发的示例，我们选取host_filter.go插件来试图编译一次。</p>

<ol>
<li>
<p>在Heka的源码编译目录创建放置插件代码的目录</p>

<pre><code>mkdir -p externals/example</code></pre>
</li>

<li>
<p>将host_filter.go拷贝到刚创建的目录中</p>

<pre><code>cp examples/host_filter.go externals/example/</code></pre>
</li>

<li>
<p>在cmake目录创建plugin_loader.cmake文件，内容：</p>

<pre><code>add_external_plugin(svn http://xx.taobao.com/trunk/example :local)</code></pre>

<p>注意：svn路径的最后一个目录名字必须与第一步创建的目录相同；<strong>:local</strong>标志就是代表从第一步创建的externals目录获取源码，否则就会自动的从此svn地址checkout源码来编译，所以插件开发阶段此处应该是<strong>:local</strong>。</p>
</li>

<li>
<p>最后重新编译Heka</p>

<pre><code>sh build.sh</code></pre>

<p>现在build出来的hekad二进制文件就已经包含了新增加的插件了。</p>
</li>
</ol>
<br />
<h4 id='id21'>插件开发</h4>

<p>Heka可以采用Go或者Lua开发插件，本文只介绍Go语言开发插件。具体业务数据计算需求基本都是通过开发Filter插件来完成，介绍一个Filter插件的大体框架：</p>

<pre><code>type DemoFilter struct {

}

func (f *DemoFilter) Init(config interface{}) error {
	return nil
}

func (f *DemoFilter) Run(runner pipeline.FilterRunner, helper pipeline.PluginHelper) (
	err error) {
	
	for pack := range runner.InChan() {
	
		pack.Recycle()	
	}
	
	
	return
}

func init() {
	pipeline.RegisterPlugin(&quot;DemoFilter&quot;, func() interface{} {
		return new(DemoFilter)
	})
}</code></pre>

<p>开发一个Filter插件，只需要定义一个插件对象，然后将对象通过init函数注册上插件即可。此处我们将filter插件对象定义为<code>DemoFilter</code>，它同时需要实现<code>Init</code>和<code>Run</code>两个方法，Init方法主要是获取配置文件设置的配置选项；Run方法是监听自己的输入channel，接收消息，然后进行处理。</p>
<br />
<pre><code>pipeline.RegisterPlugin(&quot;DemoFilter&quot;, func() interface{} {
	return new(DemoFilter)
})</code></pre>

<p>&#8220;DemoFilter&#8221;字符串是插件的名字或者也可以当做类型。这个将在配置文件使用。</p>
<br />
<pre><code>for pack := range runner.InChan() {
	
	pack.Recycle()	
}</code></pre>

<p>runner.InChan()调用其实是返回的插件的输入channel，也就是数据将从这里流入到这个插件，pack就是获取到的一个消息，消息类型是：<code>*PipelinePack</code>，所有进入Heka的数据都被封装成了PipelinePack在内部各个组件之间传输，这是插件开发将直接打交道的最重要的一个对象。当我们把一个pack处理完后，不再需要将pack传递给下一个组件时，也就是这个pack的生命结束，那么我们需要释放它，于是调用pack.Recycle()方法。Recycle的目的是缓存pack对象，留给下一个数据使用，可以降低gc压力。</p>
<br />
<p>Filter插件的开发，可以学习examples/host_filter.go。Heka本身就自带了很多的插件，都可以作为学习的目标。我觉得要深刻的理解插件开发，还是需要熟悉heka核心源码才行。</p>
<br />
<p>玩开心。。。</p>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
     
    	<li><a href="/categories.html#system-ref">
    		system <span>7</span>
    	</a></li>
    
  


    </ul>
    

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags.html#Heka-ref">Heka <span>1</span></a></li>
     
    	<li><a href="/tags.html#Go-ref">Go <span>15</span></a></li>
    
  



    </ul>
    

    <hr>
    


  <!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1905720"></script>
<!-- UY END -->





  </div>
</div>


          </div>
        </div>

        <div class="span3" style="padding-top:40px">
          <div style="color:#E74C3C">友情链接</div>
          <ul><a href="http://blog.csdn.net/marcky" target="_blank">My CSDN Blog</a></ul>

           
          <div style="color:#E74C3C">eg</div>
          <ul>
              
            


  
    
      
      	
      	<li><a href="/eg/1970/01/01/example">example</a></li>
      	
      
    
  



          </ul>
           
          <div style="color:#E74C3C">go</div>
          <ul>
              
            


  
    
      
      	
      	<li><a href="/go/2014/04/21/go-net-core">深入Go语言网络库的基础实现</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/11/29/golang-schedule">goroutine与调度器</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/11/11/go-runtime-mind">Go runtime中的那些东东</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/10/13/go-memory-manage-system-alloc">Go语言内存分配器的实现</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/10/11/go-memory-manage-system-span">Go语言内存分配器-MSpan</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/10/09/go-memory-manage-system-fixalloc">Go语言内存分配器-FixAlloc</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/10/08/go-memory-manage-system-design">Go语言内存分配器设计</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/09/28/go-select-memory-test">Go语言select的内存分配情况</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/09/26/go-runtime-select">select in Go's runtime</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/09/20/go-runtime-channel">channel in Go's runtime</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/09/12/go-runtime-timer">timer in Go's runtime</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/09/10/go-rpc-benchmark">Go RPC Benchmark</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/09/01/go-rpcserver-inside">Go RPC Inside (server)</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/go/2013/08/28/go-rpcclient-inside">Go RPC Inside (client)</a></li>
      	
      
    
  



          </ul>
           
          <div style="color:#E74C3C">vim</div>
          <ul>
              
            


  
    
      
      	
      	<li><a href="/vim/2013/09/18/vim-plugin-manager">使用github管理我的Vim</a></li>
      	
      
    
  



          </ul>
           
          <div style="color:#E74C3C">algorithm</div>
          <ul>
              
            


  
    
      
      	
      	<li><a href="/algorithm/2013/09/30/base-128-varint">Base 128 Varint, 一种处理整数的变长二进制编码算法</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/algorithm/2013/09/28/shuffle-algorithm">一个洗牌场景及算法</a></li>
      	
      
    
  



          </ul>
           
          <div style="color:#E74C3C">system</div>
          <ul>
              
            


  
    
      
      	
      	<li class="active"><a href="/system/2014/04/30/heka-plugin-devel" class="active">Heka插件开发</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/system/2014/04/02/hekad">Heka, 一个高可扩展的实时数据收集和处理工具</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/system/2014/03/19/inet-aton">inet_aton的坑</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/system/2014/03/18/udp-server-performance">使用reuseport和recvmmsg优化UDP服务器</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/system/2014/03/09/cdn-scheduler-conclusion">调度开发中的那些事</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/system/2014/03/05/reuseport">reuseport</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/system/2013/11/14/rdtsc-instruction">使用cpu的时钟周期作为随机数发生器的种子</a></li>
      	
      
    
  



          </ul>
          

        </div>
      </div>
    </div>

    


  <script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-44034004-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



  </body>
</html>

